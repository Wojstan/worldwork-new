{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/helpers/ByteHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary ByteHasher {\n    /// @dev Creates a keccak256 hash of a bytestring.\n    /// @param value The bytestring to hash\n    /// @return The hash of the specified value\n    /// @dev `>> 8` makes sure that the result is included in our field\n    function hashToField(bytes memory value) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(value))) >> 8;\n    }\n}\n"
    },
    "contracts/interfaces/IWorldID.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IWorldID {\n    /// @notice Reverts if the zero-knowledge proof is invalid.\n    /// @param root The of the Merkle tree\n    /// @param groupId The id of the Semaphore group\n    /// @param signalHash A keccak256 hash of the Semaphore signal\n    /// @param nullifierHash The nullifier hash\n    /// @param externalNullifierHash A keccak256 hash of the external nullifier\n    /// @param proof The zero-knowledge proof\n    /// @dev  Note that a double-signaling check is not included here, and should be carried by the caller.\n    function verifyProof(\n        uint256 root,\n        uint256 groupId,\n        uint256 signalHash,\n        uint256 nullifierHash,\n        uint256 externalNullifierHash,\n        uint256[8] calldata proof\n    ) external view;\n}\n"
    },
    "contracts/WorldWork.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ByteHasher } from \"./helpers/ByteHasher.sol\";\nimport { IWorldID } from \"./interfaces/IWorldID.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract WorldWork {\n\tenum Stage {\n\t\tLive,\n\t\tCompleted\n\t}\n\n\tstruct Job {\n\t\taddress employer;\n\t\tSalary stablecoinSalary;\n\t\tSalary tokenSalary;\n\t\tStage stage;\n\t\taddress worker;\n\t\taddress[] applicants;\n\t}\n\n\tstruct Salary {\n\t\tuint amount;\n\t\tIERC20 token;\n\t}\n\n\tmapping(address => bool) public workers;\n\tmapping(address => bool) public employers;\n\tmapping(address => Job[]) public jobs;\n\n\t// mapping(string => VisitDetails) public visitdetails;\n\n\t// mapping(address => mapping(address => bool)) public doctorsPermissions;\n\n\tusing ByteHasher for bytes;\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t///                                  ERRORS                                ///\n\t//////////////////////////////////////////////////////////////////////////////\n\n\t/// @notice Thrown when attempting to reuse a nullifier\n\terror InvalidNullifier();\n\n\t/// @dev The World ID instance that will be used for verifying proofs\n\tIWorldID internal immutable worldId;\n\n\t/// @dev The contract's external nullifier hash\n\tuint256 internal immutable externalNullifier;\n\n\t/// @dev The World ID group ID (always 1)\n\tuint256 internal immutable groupId = 1;\n\n\taddress tokenDWL = 0x5c383F1AfdC3B39dD4367d16CB8Bb72605EB08A8;\n\n\t/// @dev Whether a nullifier hash has been used already. Used to guarantee an action is only performed once by a single person\n\tmapping(uint256 => bool) internal nullifierHashes;\n\n\tevent EmployerRegistered(address indexed employer);\n\tevent WorkerRegistered(address indexed patient);\n\t// event VisitFinalized(\n\t// \taddress indexed patient,\n\t// \taddress indexed doctor,\n\t// \tstring visitCid,\n\t// \tuint price\n\t// );\n\t// event TransactionPaid(string visitCid);\n\n\t/// @param _worldId The WorldID instance that will verify the proofs\n\t/// @param _appId The World ID app ID\n\t/// @param _actionId The World ID action ID\n\tconstructor(\n\t\tIWorldID _worldId,\n\t\tstring memory _appId,\n\t\tstring memory _actionId\n\t) {\n\t\tworldId = _worldId;\n\t\texternalNullifier = abi\n\t\t\t.encodePacked(abi.encodePacked(_appId).hashToField(), _actionId)\n\t\t\t.hashToField();\n\t}\n\n\t/// @param signal An arbitrary input from the user, usually the user's wallet address (check README for further details)\n\t/// @param root The root of the Merkle tree (returned by the JS widget).\n\t/// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the JS widget).\n\t/// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the JS widget).\n\t/// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.\n\tfunction registerWorker(\n\t\taddress signal,\n\t\tuint256 root,\n\t\tuint256 nullifierHash,\n\t\tuint256[8] calldata proof\n\t) public {\n\t\t// First, we make sure this person hasn't done this before\n\t\tif (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n\t\trequire(!workers[signal], \"Worker already registered\");\n\t\trequire(!employers[signal], \"Employer already registered\");\n\n\t\t// We now verify the provided proof is valid and the user is verified by World ID\n\t\tworldId.verifyProof(\n\t\t\troot,\n\t\t\tgroupId,\n\t\t\tabi.encodePacked(signal).hashToField(),\n\t\t\tnullifierHash,\n\t\t\texternalNullifier,\n\t\t\tproof\n\t\t);\n\n\t\t// We now record the user has done this, so they can't do it again (proof of uniqueness)\n\t\tnullifierHashes[nullifierHash] = true;\n\n\t\tworkers[signal] = true;\n\n\t\temit WorkerRegistered(signal);\n\n\t\t// Finally, execute your logic here, for example issue a token, NFT, etc...\n\t\t// Make sure to emit some kind of event afterwards!\n\t}\n\n\t// function registerPatient() public {\n\t//     patients.push(msg.sender);\n\t// }\n\n\t/// @param signal An arbitrary input from the user, usually the user's wallet address (check README for further details)\n\t/// @param root The root of the Merkle tree (returned by the JS widget).\n\t/// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the JS widget).\n\t/// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the JS widget).\n\t/// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.\n\tfunction registerEmployer(\n\t\taddress signal,\n\t\tuint256 root,\n\t\tuint256 nullifierHash,\n\t\tuint256[8] calldata proof\n\t) public {\n\t\t// First, we make sure this person hasn't done this before\n\t\tif (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n\t\trequire(!workers[signal], \"Worker already registered\");\n\t\trequire(!employers[signal], \"Employer already registered\");\n\t\t// We now verify the provided proof is valid and the user is verified by World ID\n\t\tworldId.verifyProof(\n\t\t\troot,\n\t\t\tgroupId,\n\t\t\tabi.encodePacked(signal).hashToField(),\n\t\t\tnullifierHash,\n\t\t\texternalNullifier,\n\t\t\tproof\n\t\t);\n\n\t\t// We now record the user has done this, so they can't do it again (proof of uniqueness)\n\t\tnullifierHashes[nullifierHash] = true;\n\n\t\temployers[signal] = true;\n\n\t\temit EmployerRegistered(signal);\n\t}\n\n\tfunction addJobOffer(uint stablecoinSalary, uint tokenSalary) public {\n\t\trequire(employers[msg.sender], \"Only employers can add job offers\");\n\t\tjobs[msg.sender].push(\n\t\t\tJob(\n\t\t\t\tmsg.sender,\n\t\t\t\tSalary(stablecoinSalary, IERC20(tokenDWL)),\n\t\t\t\tSalary(tokenSalary, IERC20(tokenDWL)),\n\t\t\t\tStage.Live,\n\t\t\t\taddress(0),\n\t\t\t\tnew address[](0)\n\t\t\t)\n\t\t);\n\t}\n\n\tfunction applyForJob(address employer, uint index) public {\n\t\trequire(workers[msg.sender], \"Only workers can apply for jobs\");\n\t\trequire(\n\t\t\temployers[employer],\n\t\t\t\"Only employers can have job applications\"\n\t\t);\n\t\tjobs[employer][index].applicants.push(msg.sender);\n\t}\n\n\tfunction acceptWorker(address worker, uint index) public {\n\t\trequire(employers[msg.sender], \"Only employers can accept workers\");\n\t\trequire(workers[worker], \"Only workers can be accepted\");\n\t\tjobs[msg.sender][index].worker = worker;\n\t}\n\n\tfunction deactivateJob(uint index) public {\n\t\trequire(employers[msg.sender], \"Only employers can complete jobs\");\n\t\tjobs[msg.sender][index].stage = Stage.Completed;\n\t}\n\n\tfunction addDefaultValuesEmployer(address adr) public {\n\t\temployers[adr] = true;\n\t}\n\n\tfunction addDefaultValuesWorker(address adr) public {\n\t\tworkers[adr] = true;\n\t}\n\n\tfunction addDefaultJobOffer(address employer) public {\n\t\tjobs[employer].push(\n\t\t\tJob(\n\t\t\t\temployer,\n\t\t\t\tSalary(100, IERC20(address(0))),\n\t\t\t\tSalary(100, IERC20(address(0))),\n\t\t\t\tStage.Live,\n\t\t\t\taddress(0),\n\t\t\t\tnew address[](0)\n\t\t\t)\n\t\t);\n\t}\n\n\t\tfunction addDefaultJobOfferWithWorker(address employer, address worker) public {\n\t\tjobs[employer].push(\n\t\t\tJob(\n\t\t\t\temployer,\n\t\t\t\tSalary(100, IERC20(address(0))),\n\t\t\t\tSalary(100, IERC20(address(0))),\n\t\t\t\tStage.Live,\n\t\t\t\tworker,\n\t\t\t\tnew address[](0)\n\t\t\t)\n\t\t);\n\t}\n\n\tfunction testApplyForJob(address employer, uint index, address testAddress) public {\n\t\tjobs[employer][index].applicants.push(testAddress);\n\t}\n\n\tfunction getJobs(address employer) public view returns (Job[] memory) {\n\t\treturn jobs[employer];\n\t}\n\n\tfunction getJobApplicants(address employer, uint index)\n\t\tpublic\n\t\tview\n\t\treturns (address[] memory)\n\t{\n\t\treturn jobs[employer][index].applicants;\n\t}\n\n\t// function finalizeVisit(\n\t// \taddress patient,\n\t// \taddress doctor,\n\t// \tstring calldata visitCid,\n\t// \tuint price\n\t// ) public {\n\t// \trequire(doctors[doctor], \"Only doctors can add documents\");\n\t// \trequire(patients[patient], \"Only patients can have documents\");\n\t//     require(doctorsPermissions[doctor][patient], \"Doctor does not have permission to access patient's profile\");\n\t// \tvisitdetails[visitCid] = VisitDetails(price, false, doctor, patient);\n\t// \temit VisitFinalized(patient, doctor, visitCid, price);\n\t// }\n\n\t// function shareProfile(address doctor) public {\n\t// \trequire(doctors[doctor], \"Only doctors can be shared with\");\n\t// \trequire(patients[msg.sender], \"Only patients can share their profile\");\n\t// \tdoctorsPermissions[doctor][msg.sender] = true;\n\t// }\n\n\t// function revokeProfile(address doctor) public {\n\t// \trequire(doctors[doctor], \"Only doctors can be shared with\");\n\t// \trequire(patients[msg.sender], \"Only patients can share their profile\");\n\t// \tdoctorsPermissions[doctor][msg.sender] = false;\n\t// }\n\n\t// function payForVisit(string calldata visitCid) public payable {\n\t// \trequire(patients[msg.sender], \"Only patients can pay for visits\");\n\t// \trequire(\n\t// \t\tvisitdetails[visitCid].patient == msg.sender,\n\t// \t\t\"Only the patient can pay for the visit\"\n\t// \t);\n\t// \trequire(\n\t// \t\tvisitdetails[visitCid].paid == false,\n\t// \t\t\"The visit has already been paid for\"\n\t// \t);\n\t// \trequire(visitdetails[visitCid].price == msg.value, \"Bad value\");\n\t// \t// Transfer the payment to the doctor\n\t// \tpayable(visitdetails[visitCid].doctor).transfer(msg.value);\n\t// \t// Mark the visit as paid\n\t// \tvisitdetails[visitCid].paid = true;\n\t// \trevokeProfile(visitdetails[visitCid].doctor);\n\t// \temit TransactionPaid(visitCid);\n\t// }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}